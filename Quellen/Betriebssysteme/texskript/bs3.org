Trotz der rasanten Entwicklung der Speichertechnologie gilt nach wie
vor, daß

-  schnelle Speicher eine geringe Kapazität und hohe Kosten pro
   gespeichertem Bit aufweisen,

-  große Speicher langsam sind aber geringe Kosten pro gespeichertem Bit
   aufweisen.

Das Ziel jeder Speicherverwaltung ist es, den Prozessen einen schnellen
Speicher scheinbar unbegrenzter Kapazität zur Verfügung zu stellen.
Gegenstand der Speicherverwaltung des Betriebssystems sind die
Speichertypen:

-  Massenspeicher (Plattenspeicher)

-  Hauptspeicher (Halbleiter-RAMs)

Abbildung [Hauptspeicheraufteilung] zeigt die Aufteilung des
Hauptspeichers.

(20,10) (0,1)

(6,5)

| Benutzer-   |
| programm    |

(0,6)(6,2)(leer) (0,8)(6,2)damals: (7,1)(6,2)Betriebssystem (7,3)

(6,4)

| Benutzer-   |
| programm    |

(7,7)(6,1)(leer) (7,8)(6,2)früher: (14,1)(6,1)Betriebssystem (14,2)

(6,4)

| Benutzer-   |
| programme   |

(14,6)(6,1)(leer) (14,7)(6,1)Gerätetreiber (14,8)(6,2)heute:
(20,7)(2,1)[l]$\}$ROM

Um einen idealen Speicher, d.h. einen beliebig großen, schnellen und
obendrein noch billigen Speicher, mit organisatorischen Mittell
nachzubilden, baut man aus verschiedenen Speicherarten eine Hierarchie
auf (s. Abbildung [Speicherhierarchie]). Die unterschiedlichen
Zugriffszeiten resultieren u.a. auch aus unterschiedlichen
Zugriffsverfahren. Während Registerspeicher, Cache und Hauptspeicher
wahlfreien Zugriff erlauben, ist bei Massenspeichern sequentieller
Zugriff erforderlich.

(23,8) (0,0)(5,1)1-10ns (0,1)(5,1)32 words (0,2)(5,2)Registerspeicher
(6,0)(5,1)1-10ns (6,1)(5,2)8-256KB (6,3)(5,2)Cache (12,0)(5,1)10-100ns
(12,1)(5,3)16-500MB (12,4)(5,2)Hauptspeicher (18,0)(5,1)$\approx$10ms
(18,1)(5,6)$\infty$ (18,7)(5,2)Massenspeicher

* Pufferspeicher (Cache-Memory)
  :PROPERTIES:
  :CUSTOM_ID: pufferspeicher-cache-memory
  :END:

Obwohl das Zusammenspiel zwischen Haupt- und Pufferspeicher vollständig
durch die Hardware gesteuert wird, soll in diesem Abschnitt kurz die
prinzipielle Pufferspeicher-Organisation mit Hilfe eines
Assoziativ-Speichers gezeigt werden, da die Prinzipien des
Zusammenwirkens zwischen Hauptspeicher und virtuellem Speicher ähnlich
sind. Abbildung [CAM] zeigt die heute in Rechnern vorkommenden
Speichertypen mit wahlfreiem Zugriff. Ein Assoziativspeicher zeichnet
sich dadurch aus, daß nicht nur der Inhaltsspeicher variabel ist,
sondern auch der Adreßspeicher.

(24,7) (0,6)(7,1)RAM (0,2)(0,1)2 (0,4)(2,1)2 (2,5)(0,-1)4 (2,1)(-2,1)2
(2,2)(1,2) (3,1)(4,4) (1,6)(0,-1)1.5 (2,3)(1,0)1 (3,2.5)(4,1)Inhalt
(5,6)(0,-1)1 (5,1)(0,-1)1 (9,6)(5,1)ROM (9,2)(0,1)2 (9,4)(2,1)2
(11,5)(0,-1)4 (11,1)(-2,1)2 (11,2)(1,2) (12,1)(0,1)4 (12,5)(2,-1)2
(14,4)(0,-1)2 (14,2)(-2,-1)2 (10,6)(0,-1)1.5 (13,1.5)(0,-1)1.5
(16,6)(8,1)CAM (16,1)(3,4) (19,2)(1,2) (20,1)(4,4) (17,6)(0,-1)1
(18,6)(0,-1)1 (16,2.5)(3,1)Adresse (19,3)(1,0)1 (20,2.5)(4,1)Inhalt
(22,6)(0,-1)1 (22,1)(0,-1)1

\\
CAM = Contents Addressable Memory (/Assoziativ-Speicher/)

(26,16) (0,5)(0,5)2(1,0)26 (8,0)(8,0)2(0,1)14 (8,10)(-2,1)8
(0,10)(8,4)[tr]Adreßspeicher (0,10)(8,4)[bl]Inhaltsspeicher
(8,10)(6,5)konstant (14,13)(1,1)1 (15,14)(0,-1)3 (15,11)(-1,1)1
(14,12)(0,1)1 (16,10)(6,5)variabel (22,11)(2,3) (0,5)(5,5)konstant
(6,6)(0,1)3 (6,9)(1,-1)1 (7,8)(0,-1)1 (7,7)(-1,-1)1 (0,0)(5,5)variabel
(5,1)(2,3) (9,8)(1,1)1 (10,9)(0,-1)3 (10,6)(-1,1)1 (9,7)(0,1)1
(10,7)(1,1) (11,6)(0,1)3 (11,9)(1,-1)1 (12,8)(0,-1)1 (12,7)(-1,-1)1
(12,5)(4,5)ROM (17,6)(2,3) (19,7)(1,1) (20,6)(0,1)3 (20,9)(1,-1)1
(21,8)(0,-1)1 (21,7)(-1,-1)1 (22,5)(4,5)irrelevant (9,3)(1,1)1
(10,4)(0,-1)3 (10,1)(-1,1)1 (9,2)(0,1)1 (10,2)(1,1) (11,1)(2,3)
(13,0)(3,5)RAM (17,1)(2,3) (19,2)(1,1) (20,1)(2,3) (22,0)(4,5)CAM

Der Hauptspeicher wird durch den Pufferspeicher gepuffert. Das bedeutet,
daß die aktuell benötigten Daten sich im Pufferspeicher befinden. Wenn
sichergestellt werden kann, daß die jeweils vom Prozessor benötigten
Daten rechtzeitig vom Hauptspeicher in den Pufferspeicher gebracht
werden, wirkt das System Hauptspeicher/Pufferspeicher wie ein Speicher
mit der Geschwindigkeit des Pufferspeichers und der Kapazität des
Hauptspeichers. Anders ausgedrückt: Der Pufferspeicher besitzt scheinbar
(virtuell) die Kapazität des Hauptspeichers. Die Bezeichnung /virtueller
Speicher/ ist hier aber nicht gebräuchlich.

Abbildung [Pufferspeicher] zeigt das Zusammenwirken von Haupt- (RAM) und
Pufferspeicher (CAM) bei einem Lesezugriff. Zunächst wird versucht, die
Adresse im Cache zu finden. Bei einem Treffer wird der Inhalt ausgegeben
(mit 1 bezeichnete Pfeile). Befindet sich die Adresse nicht im Cache,
wird auf den Hauptspeicher zugegriffen und der Inhalt ausgegeben.
Außerdem werden Adresse und Inhalt in den Pufferspeicher kopiert (mit 2
bezeichnete Pfeile).

(15,16) (1,15)(2,1)Adresse (12,0)(2,1)Wert (4,10)(0,1)2 (4,12)(2,1)2
(6,13)(0,-1)4 (6,9)(-2,1)2 (6,10)(1,2) (7,9)(4,4)RAM (2,2)(3,3)
(5,2.5)(1,2) (6,2)(4,3)CAM (2,15)(0,-1)8.5 (2,6.5)(1,0)1 (3,7)(0,-1)2
(2,7.5) (2,7.5)(1,0)2 (4,8)(0,-1)3 (2,14) (2,14)(1,0)3 (5,15)(0,-1)2.5
(9,15)(0,-1)2 (9,9)(0,-1)2 (9,7) (9,7)(-1,0)1 (9,7)(1,0)3 (8,8)(0,-1)3
(12,8)(0,-1)8 (8,1)(0,1)1 (8,1)(1,0)4 (5.5,2.5) (5.5,2.5)(0,-1)1.5
(5.5,1)(-1,0)4.5 (1,1)(0,1)2 (1.5,6.5) (1,6)(1,1)1 (10.5,0.5)
(10,0)(1,1)1 (1.5,1.5) (1,1)(1,1)2 (3.5,14.5) (3,14)(1,1)2 (10.5,7.5)
(10,7)(1,1)2

Bei Kopieren einer Speicherzelle vom Haupt- in den Pufferspeicher muß
dort eine Zelle üeberschrieben werden. Hierfür sind verschiedene
Ersetzungsstrategien gebräuchlich:

-  FIFO (First In First Out)

-  LRU (Least Recently Used)

Bei Schreibzugriffen sind zwei Strategien gebräuchlich um die Inhalte
von Haupt- und Pufferspeicher konsistent zu halten:

-  /copy back/: Hauptspeicher wird erst beschrieben, wenn die Stelle im
   Pufferspeicher ersetzt werden soll

-  /write through/: Aktualisierung bei jedem Schreibzugriff

Die Effizienz der Pufferspeicher-Organisation hängt von der Trefferquote
ab, diese wiederum von dem Verhältnis der Kapazitäten von Haupt- und
Pufferspeicher sowie den Ersetzungsalgorithmen.

* Virtueller Speicher
  :PROPERTIES:
  :CUSTOM_ID: virtueller-speicher
  :END:

Da schon immer die zur Verfügung stehende Hauptspeicherkapazität für
größere Anwendungen nicht ausreichte, gab es auch schon früher
Techniken, die Problem zu umgehen. Früher wurde dafür die sogenannte
/Overlay-Technik/ verwendet, bei der der Programmierer selbst sein
Programm in in den Speicher passende Stücke (Overlays) zerlegen mußte
und für das Ein- und Auslagern der Teile selbst sorgen mußte.
Ausgelagerte Programmteile befinden sich dabei auf einem
Hintergrundspeicher (i.d.R. Plattenspeicher).

In modernen Rechenanlagen obliegen diese Aufgaben dem Betriebssystem,
das hierzu die /virtueller Speichertechnik/ benutzt. Die virtuelle
Speichertechnik ist erst mit Mehrprogrammbetrieb effizient nutzbar.
Erfordert nämlich die Ausführung eines Prozesses das Nachladen von
Speicherbereichen vom Hintergrundspeicher, was, verglichen mit einem
Hauptspeicherzugriff, sehr viel Zeit erfordert, so wird die Ausführung
des Prozesses unterbrochen und die CPU einem anderen rechenwilligen
Prozeß zugeordnet.

Um die Organisation eines virtuellen Speichers zu verstehen, ist
zunächst der Begriff des /Adreßraums/ zu klären. Im einfachsten Fall
sind die im Programm verwendeten Adressen genau die, mit denen auf den
Speicher zugegriffen wird: Programm-Adreßraum = Speicher-Adreßraum

Bei virtuellen Speichern werden diese Adreßräume voneinander entkoppelt,
d.h. der Programm-Adreßraum wird in den Speicher-Adreß"-raum umgesetzt.
Abbildung [Adr-Raum] zeigt schematisch, wie eine Programmadresse
(virtuelle Adresse) in eine Speicheradresse mithilfe einer
Adreßumsetzungstabelle umgesetzt wird.

(20,15) (1,13)(3,1) (4,13)(7,1) (1,14)(10,1)virtuelle Adresse
(1,9)(0,1)3 (4,9)(0,1)3 (8,9)(0,1)3 (1,10)(3,1)5 (4,10)(4,1)1024
(8,10)(7,1)Adreßumrechnungstabelle (2.5,13.5) (2.5,13.5)(0,-1)2.5
(10.5,13.5) (10.5,13.5)(0,-1)5.5 (10.5,8)(-1,0)3.5 (6,10)(0,-1)1
(5,8)(-1,0)2.5 (2.5,8)(0,-1)3 (5,7)(2,2)$\bigoplus$ (1,6)(3,1)3
(4,7)(0,-1)6 (4,1)(-3,1)3 (1,2)(0,1)4 (1,4)(3,1)1024 (4,4.5)(1,0)1
(4,2)(1,4) (5,1)(0,1)6(4,1) (19,13)Hintergrundspeicher
(16,0)(2,0)2(0,1)14 (16,1)(0,2)6(2,2) (16,9.5)(-4,-3)7

Zu den Aufgaben des Betriebssystems zählt damit auch die Verwaltung des
Hauptspeichers hinsichtlich belegter und freier Speicherbereiche. Da
Programme vom Betriebssystem an beliebigen realen Adressen plaziert
werden können, müssen Programme mit ihren Daten verschiebbar
(/relocatable/) sein. Das Betriebssystem muß Sicherheit vor
Adreßraumverletzung durch Zugriffsschutz gewährleisten.

Sicherheit bedeutet hierbei:

-  Bereichsschutz :: Programm- und Datenteile dürfen bei der
   Adressierung nicht überschritten werden

-  Zugriffsschutz :: Schutz vor unzulässigen Zugriffen.

Aufgaben wie Adreßumsetzung, Bereichsschutz und Zugriffsschutz werden
vom Betriebssystem in Zusammenarbeit mit einer
Speicherverwaltungseinheit (/Memory Management Unit/, MMU,
Spezialhardware) erledigt.

Bezüglich der Zerlegung von Programmen und Daten in Teile, die dann ein-
bzw. ausgelagert werden können unterscheidet man grundsätzlich zwei
Möglichkeiten: Zerlegung in /Segmente/ oder /Seiten/.

** Logische Zerlegung in Segmente
   :PROPERTIES:
   :CUSTOM_ID: logische-zerlegung-in-segmente
   :END:

Die Zerlegung in /Segmente/ ist an der Programmstruktur orientiert, z.B.
in Prozedursegmente und Datensegmente. Segmente haben variable Längen.

**** virtuelle Adressierung:
     :PROPERTIES:
     :CUSTOM_ID: virtuelle-adressierung
     :END:

(eines Bytes)

-  Angabe einer /Segmentnummer/

-  Angabe einer /Bytenummer/ innerhalb des Segments

**** reale Adressierung:
     :PROPERTIES:
     :CUSTOM_ID: reale-adressierung
     :END:

-  Angabe der /Segment-Basisadresse/

-  hinzuaddieren der Bytenummer

Abbildung [Segmente] zeigt den Zusammenhang zwischen logischen und
physischen Segmenten.

(16,14) (0,13.5)logische Strukturierung (1,9)(5,3)Segment 0
(0,11)(1,1)$0$ (0,9)(1,1)$m$ (1,3)(5,5)Segment 1 (0,7)(1,1)$0$
(0,3)(1,1)$n$ (1,0)(5,2)Segment 2 (0,1)(1,1)$0$ (0,0)(1,1)$p$
(10,13.5)physischer Adreßraum (10,10)(5,2)Segment 2 (15.5,11)$0=$
Segmentbasisadresse (10,7)(5,3) (10,4)(5,3)Segment 0 (15.5,6)$x=$
Segmentbasisadresse (10,1)(5,3) (6,1)(1,0)1 (7,1)(0,1)10 (7,11)(1,0)3
(6,10.5)(1,0)2 (8,10.5)(0,-1)5 (8,5.5)(1,0)2

**** Segmentverwaltung:
     :PROPERTIES:
     :CUSTOM_ID: segmentverwaltung
     :END:

Jedem Segment ist sind die folgenden Informationen zugeordnet:

-  Segmentbasisadresse

-  Längenangabe für Bereichsschutz

-  Zugriffsattribut für Zugriffsschutz

-  Hinweis, ob das Segment im Hauptspeicher geladen ist oder nicht

-  Hinweis, ob das Segment im Hauptspeicher verändert wurde (/dirty
   tag/)

Diese Angaben werden in einem /Segmentdeskriptor/ zusammengefaßt. Die
Segmentdeskriptoren werden in einer /Segmenttabelle/ verwaltet.

**** Vorteile der Segmentierung:
     :PROPERTIES:
     :CUSTOM_ID: vorteile-der-segmentierung
     :END:

-  Segmente sind /logische/ Einheiten, denen spezifische Merkmale
   zugeordnet werden können.

-  Überlappende Segmente sind durch geeignete Wahl von Basisadressen und
   Längen möglich (z.B. /shared code/, d.h. gemeinsame Nutzung von
   Programm(teil)en durch verschiedene Prozesse).

-  Die Segmentlänge kann dynamisch verändert werden (z.B.
   /Stack/-Segmente).

**** Nachteile:
     :PROPERTIES:
     :CUSTOM_ID: nachteile
     :END:

-  Die variable Länge der Segmente führt zu aufwendiger Verwaltung der
   freien und belegten Bereiche im Hauptspeicher
   (/Freispeicherverwaltung/).

-  Segmente müssen komplett geladen bzw. ausgelagert werden.

-  Das Ein- und Auslagern variabel langer Segmente kann zu einer
   ungünstigen Stückelung des freien Speichers im Hauptspeicher führen.
   Das kann zur Folge haben, daß ein großes Segment nicht geladen werden
   kann, weil kein ausreichend großes zusammenhängendes Stück Speicher
   mehr frei ist, obwohl insgesamt noch genügend Speicher vorhanden
   wäre.

** Physische Zerlegung in Seiten
   :PROPERTIES:
   :CUSTOM_ID: physische-zerlegung-in-seiten
   :END:

Die Verwaltung des Adreßraumes erfolgt hier nach physischen
Gesichtspunkten. Virtueller und realer Adreßraum werden in Bereiche
konstanter Größe (Seiten (/pages/) oder Rahmen (/frames/)) zerlegt. Die
Größe einer Seite ist immer eine Zweier-Potenz (zwischen 512 Bytes und
8KB). Abbildung [Seiten] zeigt die Zuordnung von Seiten des virtuellen
Adreßraums zu Rahmen des Hauptspeichers.

(25,12) (0,7)(5,5)Segmente (5,10)(5,2)Seite $0$ (5,8)(5,2)Seite $1$
(5,6)(5,2)Seite $2$ (5,4)(5,2)Seite $3$ (5,2)(5,2) (5,0)(5,2)Seite $n$
(10,11)(1,0)5 (10,9)(1,0)2 (12,9)(0,-1)2 (12,7)(1,0)3 (10,5)(1,0)3
(13,5)(0,1)4 (13,9)(1,0)2 (15,10)(5,2)Seite $0$ (15,8)(5,2)Seite $3$
(15,6)(5,2)Seite $1$ (15,4)(5,2) (20,10)(5,2)Rahmen $0$
(20,8)(5,2)Rahmen $1$ (20,6)(5,2)Rahmen $2$ (20,4)(5,2)Rahmen $3$
(4.5,12)(0,-5)2(1,0)0.5 (4.5,12)(0,-1)5

Jede Seite wird durch einen Deskriptor beschrieben:

-  Seitennummer (Rahmennummer)

-  Zugriffsattribut

-  Hinweis, ob die Seite geladen ist

-  Hinweis, ob die Seite verändert wurde

Abbildung [Seitenadressierung] zeigt, wie eine realen
Hauptspeicheradresse aus Rahmennummer und Bytenummer zusammensetzt wird.

(13,9) (0,7)(3,1)Seiten-Nr. (3,7)(7,1)Byte-Nr. (0,8)(10,1)virtuelle
Adresse (1.5,7)(0,-1)2 (8,7)(0,-1)5 (0,3)(3,0)3(0,1)3 (0,4)(3,1)Seite
$x$ (3,4)(3,1)Rahmen $y$ (4.5,4)(0,-1)2 (3,1)(3,1)Rahmen-Nr.
(6,1)(7,1)Byte-Nr. (3,0)(10,1)reale Adresse

**** Vorteile der Aufteilung des Speichers in Seiten:
     :PROPERTIES:
     :CUSTOM_ID: vorteile-der-aufteilung-des-speichers-in-seiten
     :END:

-  Nur die aktuell benötigten Teile des Programms und seiner Daten
   werden im Hauptspeicher gehalten.

-  Das Problem der Freispeicherverwaltung entfällt.

**** Nachteile:
     :PROPERTIES:
     :CUSTOM_ID: nachteile-1
     :END:

-  Die Zuordnung logischer Merkmale (von Segmenten) muß zu allen
   betroffenen Seiten erfolgen

-  Eine Seitentabelle ist viel größer als eine Segmenttabelle.

Im Zusammenhang mit der virtuellen Speicherverwaltung sind noch folgende
Begriffe von Bedeutung:

**** /Working set/:
     :PROPERTIES:
     :CUSTOM_ID: working-set
     :END:

Die Menge der einem Prozeß aktuell zugehörigen Seiten (Rahmen) im
Hauptspeicher

**** /Page fault/:
     :PROPERTIES:
     :CUSTOM_ID: page-fault
     :END:

Zugriff auf eine Seite, die sich nicht im Hauptspeicher befindet. Ein
Page fault führt zur Unterbechung des Prozessors und Aktivierung des
Betriebssystems (Scheduler).

**** Seitenflattern (/thrashing/):
     :PROPERTIES:
     :CUSTOM_ID: seitenflattern-thrashing
     :END:

Das Betriebssystem lagert aufgrund einer Überlast rechenwilliger
Prozesse ständig Prozesse aus und wieder ein.

Um die Nachteile zu vermeiden bzw. die Vorteile der Segment- und der
Seitenaufteilung zu kombinieren, wird häufig eine kombinierte
Segment-/Seitenverwaltung benutzt, bei der der Speicher zunächst in
logische, variabel lange Segmente und diese wiederum in Seiten fester
Länge unterteilt (vgl. z.B. \cite{Liebig}) werden.

** Algorithmen für die Plazierung variabel langer Segmente im
Hauptspeicher
   :PROPERTIES:
   :CUSTOM_ID: algorithmen-für-die-plazierung-variabel-langer-segmente-im-hauptspeicher
   :END:

In diesem Abschnitt soll kurz auf die Probleme einer
Freispeicherverwaltung eingegangen werden, wie sie z.B. bei der
Verwaltung variabel langer Segmente eines virtuellen Speichers oder auf
dem Heap im Laufzeitsystem einer höheren Programmiersprache auftreten.
Grundsätzlich kann hierbei die Speicheraufteilung in freie und belegte
Bereiche nicht vorhergesagt werden. Eine mögliche Situation zeigt
Abbildung [Speicheraufteilung].

(4,15) (0,14)(5,1)Speicher: (0,12)(5,2)Loch (0,9)(5,3)Segment 1
(0,7)(5,2)Segment 2 (0,5)(5,2)Loch (0,4)(5,1)Segment 3 (0,1)(5,3)Loch
(0,0)(5,0)2(0,1)1

Beim Versuch, ein neues Segment im Hauptspeicher zu plazieren, könnten
die folgenden Situationen auftreten:

1. Ein Segment soll plaziert werden, mindestens ein Loch ausreichender
   Größe ist vorhanden.

2. Kein Loch ist groß genug für das zu plazierende Segment, aber die
   Summe mehrerer Löcher würde ausreichen.

3. Der freie Platz insgesamt reicht nicht aus, um einen anstehendes
   Segment aufzunehmen.

**** Fall 1.:
     :PROPERTIES:
     :CUSTOM_ID: fall-1.
     :END:

Es gibt folgende Strategien:

1. Man wähle das kleinste Loch (/best fit/)\\
   Vorteil: Große Löcher werden nicht zerlegt.\\
   Nachteil: Fragmentierung in viele kleine Löcher

2. Man wähle das erste Loch (/first fit/)\\
   Vorteil: Diese Methode ist am schnellsten

3. Man wähle das größte Loch (/worst fit/)\\
   Ziel: Löcher sollen möglichst groß sein

**** Fall 2.:
     :PROPERTIES:
     :CUSTOM_ID: fall-2.
     :END:

Es wird Platz geschaffen durch Verschieben der Segmente, dabei brauchen
nur die Basisadressen der Segmente verändert werden.

**** Fall 3.:
     :PROPERTIES:
     :CUSTOM_ID: fall-3.
     :END:

In diesem Fall kann Platz nur durch Auslagern von Segmenten zur
Verfügung gestellt werden.
