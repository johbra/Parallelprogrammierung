% bs-Script% Kapitel 3%Trotz der rasanten Entwicklung der Speichertechnologie gilt nach wie vor, daß\begin{itemize}	\item  schnelle Speicher eine geringe Kapazität und hohe Kosten pro 	gespeichertem Bit aufweisen,	\item  große Speicher langsam sind aber geringe Kosten pro 	gespeichertem Bit aufweisen.\end{itemize}Das Ziel jeder Speicherverwaltung ist es, den Prozessen einen schnellen Speicher scheinbar unbegrenzter Kapazität zur Verfügung zu stellen. Gegenstand der Speicherverwaltung des Betriebssystems sind die Speichertypen:\begin{itemize}\item	Massenspeicher (Plattenspeicher)\item	Hauptspeicher (Halbleiter-RAMs) \end{itemize}Abbildung \ref{Hauptspeicheraufteilung} zeigt die Aufteilung des Hauptspeichers.\begin{figure}[tbp]\setlength{\unitlength}{5mm}\begin{picture}(20,10)        \put(0,1){\framebox(6,5){\begin{tabular}{c}Benutzer-\\programm\end{tabular}}}        \put(0,6){\framebox(6,2){(leer)}}        \put(0,8){\makebox(6,2){damals:}}        \put(7,1){\framebox(6,2){Betriebssystem}}        \put(7,3){\framebox(6,4){\begin{tabular}{c}Benutzer-\\programm\end{tabular}}}        \put(7,7){\framebox(6,1){(leer)}}        \put(7,8){\makebox(6,2){früher:}}        \put(14,1){\framebox(6,1){Betriebssystem}}        \put(14,2){\framebox(6,4){\begin{tabular}{c}Benutzer-\\programme\end{tabular}}}        \put(14,6){\framebox(6,1){(leer)}}        \put(14,7){\framebox(6,1){Gerätetreiber}}        \put(14,8){\makebox(6,2){heute:}}        \put(20,7){\makebox(2,1)[l]{$\}$ROM}}\end{picture}	\caption{\label{Hauptspeicheraufteilung}  Aufteilung des Hauptspeichers}\end{figure}Um einen idealen Speicher, d.h. einen beliebig großen, schnellen und obendrein noch billigen Speicher, mit organisatorischen Mittell nachzubilden, baut man aus verschiedenen Speicherarten eine Hierarchie auf (s. Abbildung \ref{Speicherhierarchie}). Die unterschiedlichen Zugriffszeiten resultieren u.a. auch aus unterschiedlichen Zugriffsverfahren. Während Registerspeicher, Cache und Hauptspeicher wahlfreien Zugriff erlauben, ist bei Massenspeichern sequentieller Zugriff erforderlich.\begin{figure}\begin{picture}(23,8)        \put(0,0){\makebox(5,1){1-10ns}}        \put(0,1){\framebox(5,1){32 words}}        \put(0,2){\makebox(5,2){Registerspeicher}}        \put(6,0){\makebox(5,1){1-10ns}}        \put(6,1){\framebox(5,2){8-256KB}}        \put(6,3){\makebox(5,2){Cache}}        \put(12,0){\makebox(5,1){10-100ns}}        \put(12,1){\framebox(5,3){16-500MB}}        \put(12,4){\makebox(5,2){Hauptspeicher}}        \put(18,0){\makebox(5,1){$\approx$10ms}}        \put(18,1){\framebox(5,6){$\infty$}}        \put(18,7){\makebox(5,2){Massenspeicher}}\end{picture}	\caption{\label{Speicherhierarchie} Speicherhierarchie}\end{figure}\section {Pufferspeicher (Cache-Memory)}Obwohl das Zusammenspiel zwischen Haupt- und Pufferspeicher vollständig durch die Hardware gesteuert wird, soll in diesem Abschnitt kurz die prinzipielle Pufferspeicher-Organisation mit Hilfe eines Assoziativ-Speichers gezeigt werden, da die Prinzipien des Zusammenwirkens zwischen Hauptspeicher und virtuellem Speicher ähnlich sind. Abbildung \ref{CAM} zeigt die heute in Rechnern vorkommenden Speichertypen mit wahlfreiem Zugriff. Ein Assoziativspeicher zeichnet sich dadurch aus, daß nicht nur der Inhaltsspeicher variabel ist, sondern auch der Adreßspeicher.\begin{figure}[tbp]\begin{center}	\setlength{\unitlength}{4mm}\begin{picture}(24,7)        \put(0,6){\makebox(7,1){RAM}}        \put(0,2){\line(0,1){2}}        \put(0,4){\line(2,1){2}}        \put(2,5){\line(0,-1){4}}        \put(2,1){\line(-2,1){2}}        \put(2,2){\framebox(1,2)}        \put(3,1){\framebox(4,4)}        \put(1,6){\vector(0,-1){1.5}}        \put(2,3){\vector(1,0){1}}        \put(3,2.5){\framebox(4,1){Inhalt}}        \put(5,6){\vector(0,-1){1}}        \put(5,1){\vector(0,-1){1}}        \put(9,6){\makebox(5,1){ROM}}        \put(9,2){\line(0,1){2}}        \put(9,4){\line(2,1){2}}        \put(11,5){\line(0,-1){4}}        \put(11,1){\line(-2,1){2}}        \put(11,2){\framebox(1,2)}        \put(12,1){\line(0,1){4}}        \put(12,5){\line(2,-1){2}}        \put(14,4){\line(0,-1){2}}        \put(14,2){\line(-2,-1){2}}        \put(10,6){\vector(0,-1){1.5}}        \put(13,1.5){\vector(0,-1){1.5}}        \put(16,6){\makebox(8,1){CAM}}        \put(16,1){\framebox(3,4)}        \put(19,2){\framebox(1,2)}        \put(20,1){\framebox(4,4)}        \put(17,6){\vector(0,-1){1}}        \put(18,6){\vector(0,-1){1}}        \put(16,2.5){\framebox(3,1){Adresse}}        \put(19,3){\vector(1,0){1}}        \put(20,2.5){\framebox(4,1){Inhalt}}        \put(22,6){\vector(0,-1){1}}        \put(22,1){\vector(0,-1){1}}\end{picture}\\CAM = Contents Addressable Memory (\emph{Assoziativ-Speicher})\setlength{\unitlength}{4mm}\begin{picture}(26,16)        \multiput(0,5)(0,5){2}{\line(1,0){26}}        \multiput(8,0)(8,0){2}{\line(0,1){14}}        \put(8,10){\line(-2,1){8}}        \put(0,10){\makebox(8,4)[tr]{Adreßspeicher }}        \put(0,10){\makebox(8,4)[bl]{Inhaltsspeicher}}        \put(8,10){\makebox(6,5){konstant}}        \put(14,13){\line(1,1){1}}        \put(15,14){\line(0,-1){3}}        \put(15,11){\line(-1,1){1}}        \put(14,12){\line(0,1){1}}        \put(16,10){\makebox(6,5){variabel}}        \put(22,11){\framebox(2,3)}        \put(0,5){\makebox(5,5){konstant}}        \put(6,6){\line(0,1){3}}        \put(6,9){\line(1,-1){1}}        \put(7,8){\line(0,-1){1}}        \put(7,7){\line(-1,-1){1}}        \put(0,0){\makebox(5,5){variabel}}        \put(5,1){\framebox(2,3)}        \put(9,8){\line(1,1){1}}        \put(10,9){\line(0,-1){3}}        \put(10,6){\line(-1,1){1}}        \put(9,7){\line(0,1){1}}        \put(10,7){\framebox(1,1)}        \put(11,6){\line(0,1){3}}        \put(11,9){\line(1,-1){1}}        \put(12,8){\line(0,-1){1}}        \put(12,7){\line(-1,-1){1}}        \put(12,5){\makebox(4,5){ROM}}        \put(17,6){\framebox(2,3)}        \put(19,7){\framebox(1,1)}        \put(20,6){\line(0,1){3}}        \put(20,9){\line(1,-1){1}}        \put(21,8){\line(0,-1){1}}        \put(21,7){\line(-1,-1){1}}        \put(22,5){\makebox(4,5){irrelevant}}        \put(9,3){\line(1,1){1}}        \put(10,4){\line(0,-1){3}}        \put(10,1){\line(-1,1){1}}        \put(9,2){\line(0,1){1}}        \put(10,2){\framebox(1,1)}        \put(11,1){\framebox(2,3)}        \put(13,0){\makebox(3,5){RAM}}        \put(17,1){\framebox(2,3)}        \put(19,2){\framebox(1,1)}        \put(20,1){\framebox(2,3)}        \put(22,0){\makebox(4,5){CAM}}\end{picture}\end{center}	\caption{\label {CAM} Varianten von Speichern mit wahlfreiem Zugriff}\end{figure}Der Hauptspeicher wird durch den Pufferspeicher gepuffert. Das bedeutet, daß die aktuell benötigten Daten sich im Pufferspeicher befinden. Wenn sichergestellt werden kann, daß die jeweils vom Prozessor benötigten Daten rechtzeitig vom Hauptspeicher in den Pufferspeicher gebracht werden, wirkt das System Hauptspeicher/Pufferspeicher wie ein Speicher mit der Geschwindigkeit des Pufferspeichers und der Kapazität des Hauptspeichers. Anders ausgedrückt: Der Pufferspeicher besitzt scheinbar (virtuell) die Kapazität des Hauptspeichers. Die Bezeichnung \emph{virtueller Speicher} ist hier aber nicht gebräuchlich.Abbildung \ref {Pufferspeicher} zeigt das Zusammenwirken von Haupt- (RAM) und Pufferspeicher (CAM) bei einem Lesezugriff. Zunächst wird versucht, die Adresse im Cache zu finden. Bei einem Treffer wird der Inhalt ausgegeben (mit 1 bezeichnete Pfeile). Befindet sich die Adresse nicht im Cache, wird auf den Hauptspeicher zugegriffen und der Inhalt ausgegeben. Außerdem werden Adresse und Inhalt in den Pufferspeicher kopiert (mit 2 bezeichnete Pfeile). \begin{figure}[tbp]    \begin{center}    	\setlength{\unitlength}{5mm}\begin{picture}(15,16)        \put(1,15){\makebox(2,1){Adresse}}        \put(12,0){\makebox(2,1){Wert}}        \put(4,10){\line(0,1){2}}        \put(4,12){\line(2,1){2}}        \put(6,13){\line(0,-1){4}}        \put(6,9){\line(-2,1){2}}        \put(6,10){\framebox(1,2)}        \put(7,9){\framebox(4,4){RAM}}        \put(2,2){\framebox(3,3)}        \put(5,2.5){\framebox(1,2)}        \put(6,2){\framebox(4,3){CAM}}        \put(2,15){\line(0,-1){8.5}}        \put(2,6.5){\vector(1,0){1}}        \put(3,7){\vector(0,-1){2}}        \put(2,7.5){\circle*{0.2}}        \put(2,7.5){\vector(1,0){2}}        \put(4,8){\vector(0,-1){3}}        \put(2,14){\circle*{0.2}}        \put(2,14){\vector(1,0){3}}        \put(5,15){\vector(0,-1){2.5}}        \put(9,15){\vector(0,-1){2}}        \put(9,9){\line(0,-1){2}}        \put(9,7){\circle*{0.2}}        \put(9,7){\vector(-1,0){1}}        \put(9,7){\vector(1,0){3}}        \put(8,8){\vector(0,-1){3}}        \put(12,8){\vector(0,-1){8}}        \put(8,1){\line(0,1){1}}        \put(8,1){\vector(1,0){4}}        \put(5.5,2.5){\circle*{0.2}}        \put(5.5,2.5){\line(0,-1){1.5}}        \put(5.5,1){\line(-1,0){4.5}}        \put(1,1){\vector(0,1){2}}        \put(1.5,6.5){\circle{0.6}}        \put(1,6){\makebox(1,1){1}}        \put(10.5,0.5){\circle{0.6}}        \put(10,0){\makebox(1,1){1}}        \put(1.5,1.5){\circle{0.6}}        \put(1,1){\makebox(1,1){2}}        \put(3.5,14.5){\circle{0.6}}        \put(3,14){\makebox(1,1){2}}        \put(10.5,7.5){\circle{0.6}}        \put(10,7){\makebox(1,1){2}}\end{picture}    \end{center}	\caption{\label {Pufferspeicher} Zusammenwirken zwischen Haupt- und 	Pufferspeicher}\end{figure}Bei Kopieren einer Speicherzelle vom Haupt- in den Pufferspeicher muß dort eine Zelle üeberschrieben werden. Hierfür sind verschiedene Ersetzungsstrategien gebräuchlich:\begin{itemize}\item   FIFO (First In First Out)\item   LRU  (Least Recently Used)\end{itemize}Bei Schreibzugriffen sind zwei Strategien gebräuchlich um die Inhalte von Haupt- und Pufferspeicher konsistent zu halten:\begin{itemize}\item \emph{copy back}:	Hauptspeicher wird erst beschrieben, wenn die Stelle im			Pufferspeicher ersetzt werden soll\item \emph{write through}:	Aktualisierung bei jedem Schreibzugriff\end{itemize}Die Effizienz der Pufferspeicher-Organisation hängt von der Trefferquote ab, diese wiederum von dem Verhältnis der Kapazitäten von Haupt- und Pufferspeicher sowie den Ersetzungsalgorithmen. \section{Virtueller Speicher}Da schon immer die zur Verfügung stehende Hauptspeicherkapazität für größere Anwendungen nicht ausreichte, gab es auch schon früher Techniken, die Problem zu umgehen. Früher wurde dafür die sogenannte \emph{Overlay-Technik}verwendet, bei der der Programmierer selbst sein Programm in in den Speicher passende Stücke (Overlays) zerlegen mußte und für das Ein- und Auslagern der Teile selbst sorgen mußte. Ausgelagerte Programmteile befinden sich dabei auf einem Hintergrundspeicher (i.d.R. Plattenspeicher).In modernen Rechenanlagen obliegen diese Aufgaben dem Betriebssystem, das hierzu die \emph{virtueller Speichertechnik}benutzt. Die virtuelle Speichertechnik ist erst mit Mehrprogrammbetrieb effizient nutzbar. Erfordert nämlich die Ausführung eines Prozesses das Nachladen von Speicherbereichen vom Hintergrundspeicher, was, verglichen mit einem Hauptspeicherzugriff, sehr viel Zeit erfordert, so wird die Ausführung des Prozesses unterbrochen und die CPU einem anderen rechenwilligen Prozeß zugeordnet.Um die Organisation eines virtuellen Speichers zu verstehen, ist zunächst der Begriff des \emph{Adreßraums} zu klären. Im einfachsten Fall sind die im Programm verwendeten Adressen genau die, mit denen auf den Speicher zugegriffen wird: 	Programm-Adreßraum = Speicher-Adreßraum	Bei virtuellen Speichern werden diese Adreßräume voneinander entkoppelt, d.h. der Programm-Adreßraum wird in den Speicher-Adreß"-raum umgesetzt. Abbildung \ref{Adr-Raum} zeigt schematisch, wie eine Programmadresse (virtuelle Adresse) in eine Speicheradresse mithilfe einer Adreßumsetzungstabelle umgesetzt wird.\begin{figure}[tbp]\begin{center}	\begin{picture}(20,15)	\put(1,13){\framebox(3,1)}	\put(4,13){\framebox(7,1)}	\put(1,14){\makebox(10,1){\tiny virtuelle Adresse}}	\put(1,9){\line(0,1){3}}	\put(4,9){\line(0,1){3}}	\put(8,9){\line(0,1){3}}	\put(1,10){\framebox(3,1){5}}	\put(4,10){\framebox(4,1){1024}}	\put(8,10){\makebox(7,1){\tiny Adreßumrechnungstabelle}}	\put(2.5,13.5){\circle*{0,25}}	\put(2.5,13.5){\vector(0,-1){2.5}}	\put(10.5,13.5){\circle*{0.25}}	\put(10.5,13.5){\line(0,-1){5.5}}	\put(10.5,8){\vector(-1,0){3.5}}	\put(6,10){\vector(0,-1){1}}	\put(5,8){\line(-1,0){2.5}}	\put(2.5,8){\vector(0,-1){3}}	\put(5,7){\makebox(2,2){$\bigoplus$}}	\put(1,6){\line(3,1){3}}	\put(4,7){\line(0,-1){6}}	\put(4,1){\line(-3,1){3}}	\put(1,2){\line(0,1){4}}	\put(1,4){\framebox(3,1){1024}}	\put(4,4.5){\vector(1,0){1}}	\put(4,2){\framebox(1,4)}	\multiput(5,1)(0,1){6}{\framebox(4,1)}	\put(19,13){\tiny Hintergrundspeicher}	\multiput(16,0)(2,0){2}{\line(0,1){14}}	\multiput(16,1)(0,2){6}{\framebox(2,2)}	\put(16,9.5){\vector(-4,-3){7}}\end{picture}\end{center}	\caption{\label{Adr-Raum} Umsetzung einer virtuellen in eine reale 	Adresse}\end{figure}	Zu den Aufgaben des Betriebssystems zählt damit auch die Verwaltung des Hauptspeichers hinsichtlich belegter und freier Speicherbereiche. Da Programme vom Betriebssystem an beliebigen realen Adressen plaziert werden können,  müssen Programme mit ihren Daten verschiebbar (\emph{relocatable}) sein.Das Betriebssystem muß Sicherheit vor Adreßraumverletzung durch Zugriffsschutz gewährleisten.Sicherheit bedeutet hierbei:\begin{description}\item[Bereichsschutz]	Programm- und Datenteile dürfen bei der Adressierung			nicht überschritten werden\item[Zugriffsschutz]	Schutz vor unzulässigen Zugriffen.\end{description}Aufgaben wie Adreßumsetzung, Bereichsschutz und Zugriffsschutz werden vomBetriebssystem in Zusammenarbeit mit einer Speicherverwaltungseinheit (\emph{MemoryManagement Unit}, MMU, Spezialhardware) erledigt.Bezüglich der Zerlegung von Programmen und Daten in Teile, die dann ein- bzw. ausgelagert werden können unterscheidet man grundsätzlich zwei Möglichkeiten:Zerlegung in \emph{Segmente} oder \emph{Seiten}.\subsection{Logische Zerlegung in Segmente}Die Zerlegung in \emph{Segmente} ist an der Programmstruktur orientiert, z.B.in Prozedursegmente und Datensegmente. Segmente haben variable Längen. \paragraph{virtuelle Adressierung:} (eines Bytes)\begin{itemize}\item   Angabe einer \emph{Segmentnummer}\item   Angabe einer \emph{Bytenummer} innerhalb des Segments\end{itemize}\paragraph{reale Adressierung:}\begin{itemize}\item   Angabe der \emph{Segment-Basisadresse}\item   hinzuaddieren der Bytenummer\end{itemize}Abbildung \ref{Segmente} zeigt den Zusammenhang zwischen logischen und physischen Segmenten. \begin{figure}[tbp]\begin{center}	\begin{picture}(16,14)	\put(0,13.5){\small logische Strukturierung}	\put(1,9){\framebox(5,3){Segment 0}}	\put(0,11){\makebox(1,1){$0$}}	\put(0,9){\makebox(1,1){$m$}}	\put(1,3){\framebox(5,5){Segment 1}}	\put(0,7){\makebox(1,1){$0$}}	\put(0,3){\makebox(1,1){$n$}}	\put(1,0){\framebox(5,2){Segment 2}}	\put(0,1){\makebox(1,1){$0$}}	\put(0,0){\makebox(1,1){$p$}}	\put(10,13.5){\small physischer Adreßraum}	\put(10,10){\framebox(5,2){Segment 2}}	\put(15.5,11){\tiny $0=$ Segmentbasisadresse}	\put(10,7){\framebox(5,3)}	\put(10,4){\framebox(5,3){Segment 0}}	\put(15.5,6){\tiny $x=$ Segmentbasisadresse}	\put(10,1){\framebox(5,3)}	\put(6,1){\line(1,0){1}}	\put(7,1){\line(0,1){10}}	\put(7,11){\vector(1,0){3}}	\put(6,10.5){\line(1,0){2}}	\put(8,10.5){\line(0,-1){5}}	\put(8,5.5){\vector(1,0){2}}\end{picture}	\caption{\label{Segmente} Abbildung logischer Segmente des virtuellen 	Adreßraum auf physische Segmente im Hauptspeicher}\end{center}\end{figure}\paragraph{Segmentverwaltung:}Jedem Segment ist sind die folgenden Informationen zugeordnet:\begin{itemize}\item   Segmentbasisadresse\item   Längenangabe für Bereichsschutz\item   Zugriffsattribut für Zugriffsschutz\item   Hinweis, ob das Segment im Hauptspeicher geladen ist oder nicht\item   Hinweis, ob das Segment im Hauptspeicher verändert wurde (\emph{dirty        tag})\end{itemize}Diese Angaben werden in einem \emph{Segmentdeskriptor} zusammengefaßt. Die Segmentdeskriptorenwerden in einer \emph{Segmenttabelle} verwaltet.\paragraph{Vorteile der Segmentierung:}\begin{itemize}\item   Segmente sind \emph{logische} Einheiten, denen spezifische Merkmale        zugeordnet werden können.\item   Überlappende Segmente sind durch geeignete Wahl von Basisadressen und        Längen möglich (z.B. \emph{shared code}, d.h. gemeinsame Nutzung von        Programm(teil)en durch verschiedene Prozesse).\item   Die Segmentlänge kann dynamisch verändert werden (z.B.        \emph{Stack}-Segmente).\end{itemize}\paragraph{Nachteile:}\begin{itemize}\item   Die variable Länge der Segmente führt zu aufwendiger Verwaltung der        freien und belegten Bereiche im Hauptspeicher        (\emph{Freispeicherverwaltung}).\item   Segmente müssen komplett geladen bzw. ausgelagert werden.\item   Das Ein- und Auslagern variabel langer Segmente kann zu einer ungünstigen Stückelung des freien Speichers im Hauptspeicher führen. Das kann zur Folge haben, daß ein großes Segment nicht geladen werden kann, weil kein ausreichend großes zusammenhängendes Stück Speicher mehr frei ist, obwohl insgesamt noch genügend Speicher vorhanden wäre.\end{itemize}\subsection{Physische Zerlegung in Seiten}Die Verwaltung des Adreßraumes erfolgt hier nach physischen Gesichtspunkten.Virtueller und realer Adreßraum werden in Bereiche konstanter Größe(Seiten (\emph{pages}) oder Rahmen (\emph{frames})) zerlegt. Die Größe einerSeite ist immer eine Zweier-Potenz (zwischen 512 Bytes und 8KB). Abbildung \ref{Seiten} zeigt die Zuordnung von Seiten des virtuellen Adreßraums zu Rahmen des Hauptspeichers. \begin{figure}[tbp]\begin{center}\begin{picture}(25,12)	\put(0,7){\makebox(5,5){Segmente}}	\put(5,10){\framebox(5,2){Seite $0$}}	\put(5,8){\framebox(5,2){Seite $1$}}	\put(5,6){\framebox(5,2){Seite $2$}}	\put(5,4){\framebox(5,2){Seite $3$}}	\put(5,2){\framebox(5,2)}	\put(5,0){\framebox(5,2){Seite $n$}}	\put(10,11){\vector(1,0){5}}	\put(10,9){\line(1,0){2}}	\put(12,9){\line(0,-1){2}}	\put(12,7){\vector(1,0){3}}	\put(10,5){\line(1,0){3}}	\put(13,5){\line(0,1){4}}	\put(13,9){\vector(1,0){2}}	\put(15,10){\framebox(5,2){Seite $0$}}	\put(15,8){\framebox(5,2){Seite $3$}}	\put(15,6){\framebox(5,2){Seite $1$}}	\put(15,4){\framebox(5,2)}	\put(20,10){\makebox(5,2){Rahmen $0$}}	\put(20,8){\makebox(5,2){Rahmen $1$}}	\put(20,6){\makebox(5,2){Rahmen $2$}}	\put(20,4){\makebox(5,2){Rahmen $3$}}	\multiput(4.5,12)(0,-5){2}{\line(1,0){0.5}}	\put(4.5,12){\line(0,-1){5}}\end{picture}\end{center}	\caption{\label{Seiten} Abbildung von virtuellen Seiten auf Rahmen im 	Hauptspeicher}\end{figure}Jede Seite wird durch einen Deskriptor beschrieben:\begin{itemize}\item   Seitennummer (Rahmennummer)\item   Zugriffsattribut\item   Hinweis, ob die Seite geladen ist\item   Hinweis, ob die Seite verändert wurde\end{itemize}Abbildung \ref {Seitenadressierung} zeigt, wie eine realen Hauptspeicheradresse aus Rahmennummer undBytenummer zusammensetzt wird.\begin{figure}[tbp]\begin{center}\setlength{\unitlength}{7mm}\begin{picture}(13,9)	\put(0,7){\framebox(3,1){Seiten-Nr.}}	\put(3,7){\framebox(7,1){Byte-Nr.}}	\put(0,8){\makebox(10,1){virtuelle Adresse}}	\put(1.5,7){\vector(0,-1){2}}	\put(8,7){\vector(0,-1){5}}	\multiput(0,3)(3,0){3}{\line(0,1){3}}	\put(0,4){\framebox(3,1){Seite $x$}}	\put(3,4){\framebox(3,1){Rahmen $y$}}	\put(4.5,4){\vector(0,-1){2}}	\put(3,1){\framebox(3,1){Rahmen-Nr.}}	\put(6,1){\framebox(7,1){Byte-Nr.}}	\put(3,0){\makebox(10,1){reale Adresse}}\end{picture}\end{center}	\caption{\label {Seitenadressierung} Zusammensetzung einer realen 	Hauptspeicheradresse}\end{figure}\paragraph{Vorteile der Aufteilung des Speichers in Seiten:}\begin{itemize}\item   Nur die aktuell benötigten Teile des Programms und seiner Daten werden        im Hauptspeicher gehalten.\item   Das Problem der Freispeicherverwaltung entfällt.\end{itemize}\paragraph{Nachteile:}\begin{itemize}\item   Die Zuordnung logischer Merkmale (von Segmenten) muß zu allen        betroffenen Seiten erfolgen\item   Eine Seitentabelle ist viel größer als eine Segmenttabelle.\end{itemize}Im Zusammenhang mit der virtuellen Speicherverwaltung sind noch folgende Begriffe von Bedeutung:\paragraph{\emph{Working set}:}Die Menge der einem Prozeß aktuell zugehörigen Seiten (Rahmen) imHauptspeicher\paragraph{\emph{Page fault}:}Zugriff auf eine Seite, die sich nicht im Hauptspeicher befindet. Ein Page fault führt zur Unterbechung des Prozessors und Aktivierung des Betriebssystems (Scheduler).\paragraph{Seitenflattern (\emph{thrashing}):}Das Betriebssystem lagert aufgrund einer Überlast rechenwilliger Prozesse ständig Prozesse aus und wieder ein.Um die Nachteile zu vermeiden bzw. die Vorteile der Segment- und der Seitenaufteilung zu kombinieren, wird häufig eine kombinierte Segment-/Seitenverwaltung benutzt, bei der der Speicher zunächst in logische, variabel lange Segmente und diese wiederum in Seiten fester Länge unterteilt (vgl. z.B. \cite{Liebig}) werden.\subsection{Algorithmen für die Plazierung variabel langer Segmente imHauptspeicher}In diesem Abschnitt soll kurz auf die Probleme einer Freispeicherverwaltung eingegangen werden, wie sie z.B. bei der Verwaltung variabel langer Segmente eines virtuellen Speichers oder auf dem Heap im Laufzeitsystem einer höheren Programmiersprache auftreten. Grundsätzlich kann hierbei die Speicheraufteilung in freie und belegte Bereiche nicht vorhergesagt werden. Eine mögliche Situation zeigt Abbildung\ref{Speicheraufteilung}.\begin{figure}[tbp]\begin{center}	\setlength{\unitlength}{4mm}\begin{picture}(4,15)	\put(0,14){\makebox(5,1){Speicher:}}	\put(0,12){\framebox(5,2){Loch}}	\put(0,9){\framebox(5,3){Segment 1}}	\put(0,7){\framebox(5,2){Segment 2}}	\put(0,5){\framebox(5,2){Loch}}	\put(0,4){\framebox(5,1){Segment 3}}	\put(0,1){\framebox(5,3){Loch}}	\multiput(0,0)(5,0){2}{\line(0,1){1}}\end{picture}\end{center}	\caption{\label {Speicheraufteilung} "`Momentaufnahme"' einer 	Speicheraufteilung}\end{figure}Beim Versuch, ein neues Segment im Hauptspeicher zu plazieren, könnten die folgenden Situationen auftreten:\begin{enumerate}\item   Ein Segment soll plaziert werden, mindestens ein Loch ausreichender        Größe ist vorhanden.\item   Kein Loch ist groß genug für das zu plazierende Segment, aber die        Summe mehrerer Löcher würde ausreichen.\item   Der freie Platz insgesamt reicht nicht aus, um einen anstehendes        Segment aufzunehmen.\end{enumerate}\paragraph{Fall 1.:}Es gibt folgendeStrategien:\begin{enumerate}\item   Man wähle das kleinste Loch (\emph{best fit})\\        Vorteil: Große Löcher werden nicht zerlegt.\\        Nachteil: Fragmentierung in viele kleine Löcher\item   Man wähle das erste Loch (\emph{first fit})\\        Vorteil: Diese Methode ist am schnellsten\item   Man wähle das größte Loch (\emph{worst fit})\\        Ziel: Löcher sollen möglichst groß sein\end{enumerate}\paragraph{Fall 2.:} Es wird Platz geschaffen durch Verschieben der Segmente, dabei brauchen nur die Basisadressen der Segmente verändert werden.\paragraph{Fall 3.:} In diesem Fall kann Platz nur durch Auslagern von Segmenten zur Verfügung gestellt werden. 