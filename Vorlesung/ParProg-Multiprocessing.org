#+SETUPFILE: ./theme-bigblow-local.setup
#+TITLE: Multiprocessing
#+SUBTITLE: Parallelprogrammierung
#+AUTHOR: Johannes Brauer
#+OPTIONS:   H:4
#+OPTIONS: num:nil d:true
#+OPTIONS: toc:nil
#+OPTIONS: reveal_single_file:nil
#+Language:  de
#+STARTUP: latexpreview
#+STARTUP: inlineimages
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="mycss/mystyle.css" />
# +REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_THEME: simple
#+REVEAL_TRANS: slide
#+REVEAL_HLEVEL: 1
#+REVEAL_INIT_SCRIPT: dependencies: [ { src: 'plugin/menu/menu.js', async: true },
#+REVEAL_INIT_SCRIPT:                 { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true } ]
#+REVEAL_MARGIN: 0.05
#+REVEAL_EXTRA_CSS: ./mycss/myrevealstyle.css
#+OPTIONS: reveal_control:t
# um Folien mit reveal.js erzeugen zu können:ml
# M-x load-library und dann ox-reveal

* Multiprocessing -- Grundlagen
** A first multiprocessing example in C
*** Overview
# chapter 3 firstExample.txt
... key points of the /unnamed pipe example/

+ When the program pipeExample.c is compiled and then executed from
  the command-line, it executes as a process. Here's the command to
  execute:
  : % ./pipeExample   ## On Windows: % pipeExample
+ The executing pipeExample is the /parent/ process.
+ The parent process calls the library function fork() to spawn a
  /child/ process, a clone of the parent.
  + The library function fork() makes a system call to the OS routine that spawns the child.
  + The library function fork() returns one of three values:
    + -1 :: to signal failure (e.g., the system already has too
            many processes)
    + 0 ::  to the child process
    + > 0 :: to the parent process; in particular, the /process id/
             (pid) of the child is returned to the parent, and a pid
             is always a positive integer
  + The parent and child process both execute the code that follows the call to fork().
    + fork() effectively /clones/ one process (child) from another (parent).
    + An if-else or equivalent construct is used to ensure that the
      parent does one thing and the child does something else.
      #+BEGIN_SRC C
pid_t pid = fork();   /** pid_t is a signed integer data type **/
if (-1 == pid) {      /** error: couldn't clone a new process **/
    ...                
}   
else if (0 == pid) {  /** child code follows **/
    ...
}
else {                /** parent code follows **/
    ...
}
      #+END_SRC
  + The parent waits for the child to exit so that the child does not
    become a „zombie“.
    + When a child terminates, the OS notifies the parent. If the
      parent is already terminated, it cannot be notified--and the
      child becomes an „zombie“, dead but still around.
*** using the shell
#+BEGIN_SRC sh
bash-3.2$ ls pipeExample.c 
pipeExample.c
bash-3.2$ gcc -o pipeExample pipeExample.c 
bash-3.2$ ./pipeExample
This is the winter of our discontent
bash-3.2$ 
#+END_SRC
*** Source code
#+BEGIN_SRC C
/** A first multiprocessing example: pipes in C 
    To compile (Unix-like system): gcc -o pipeExample pipeExample.c
    For Windows, the GNU compiler: https://gcc.gnu.org/
**/
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define ReadEnd  0                                                  /** line 1 **/            
#define WriteEnd 1                                                

void report_and_die(const char* msg) {                              /** line 2 **/
  perror(msg);
  exit(-1);    /** failure **/
}

int main() {
  int pipeFDs[2];                                                   /** line 3 **/
  char buf;         /* 1-byte buffer */
  const char* msg = "This is the winter of our discontent\n";

  if (pipe(pipeFDs) < 0) report_and_die("pipe(...)");               /** line 4 **/

  pid_t cpid = fork();                                              /** line 5 **/
  if (cpid < 0) report_and_die("fork()");                           /** line 6 **/

  /*** child ***/
  if (0 == cpid) {                                                  /** line 7 **/
    close(pipeFDs[WriteEnd]);                                       /** line 8 **/
    while (read(pipeFDs[ReadEnd], &buf, 1) > 0)                     /** line 9 **/
      write(STDOUT_FILENO, &buf, sizeof(buf));                      /** 1ine 10 **/
    close(pipeFDs[ReadEnd]);                                        /** line 11 **/
    _exit(0); /* signal parent of immediate exit **/                /** line 12 **/
  } 
  /*** parent ***/
  else {                                                            /** line 13 **/ 
    close(pipeFDs[ReadEnd]);                                   
    write(pipeFDs[WriteEnd], msg, strlen(msg));                     /** line 14 **/
    close(pipeFDs[WriteEnd]); /* generates an EOF */                /** line 15 **/
    wait(0); /*** wait for child to exit ***/                       /** line 16 **/  
    exit(0); /* exit normally */                                    /** line 17 **/
  }
  return 0;
}
#+END_SRC
** Second Example -- Named Pipes
*** Overview
# chapter 3 secondExample.txt
 A second multiprocessing example in C: key points of the /named pipe/ example

+ Two separate processes, but no parent/child relationship between them.
  + The processes communicate through a /named pipe/ (aka /FIFO/).
    + A named pipe is a mechanism designed to support IPC among processes on the same host.
      #+begin_example
           +------------+
writer---->| named pipe |<----reader
           +------------+
      #+end_example
+ The system implements an FIFO as a temporary file.
+ Named pipes are quite similar in functionality to Unix Domain
  Sockets, also called /local sockets/.
  + Network sockets support communcation between processes running on
    different hosts, whereas named pipes and local sockets do the same
    for processes running on the same host.
+ The example consists of two executable programs, fifoWriter and
  fifoReader, which can be executed at the command-line as follows:
  : % ./fifoWriter &    ## for Windows: fifoWriter & (& puts the process in the background) 
  : % ./fifoReader      ## for Windows: fifoReader
  + There are now two processes executing: fifoWriter and fifoReader
  + The fifoWriter writes randomly generated integers to the FIFO.
  + The fifoReader reads these integers from the FIFO until end-of-file.
  + In the C code, the FIFO is /written/ and /read/ as if it were a
    regular disk file: the I/O API is the same.
*** using the shell
#+BEGIN_SRC sh
bash-3.2$ ./fifoWriter &
[1] 7316
bash-3.2$ ./fifoReader
60749779
966803328
1202260494
...
[1]+  Done                    ./fifoWriter
bash-3.2$ 
#+END_SRC
*** Source Code =fifoWriter.c=
#+BEGIN_SRC C
#include <fcntl.h> 
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>

#define MaxWrites 256  

int main() {
  srand(time(0)); /* seed the random number generator */

  const char* fifoName = "./myPipe1";          
  mkfifo(fifoName, 0666); /* read/write for user/group/others */             /** line 1 **/
  int fd = open(fifoName, O_CREAT | O_WRONLY); /* open blocks on a FIFO */   /** line 2 **/

  int i;
  for (i = 0; i < MaxWrites; i++) { 
    int n = rand();             
    write(fd, &n, sizeof(int));  /* 4 bytes per int */                       /** line 3 **/
  }
  close(fd);         /* close the fifo */                                    /** line 4 **/
  unlink(fifoName);  /* dispose of underlying file */                        /** line 5 **/
  return 0;
}
#+END_SRC
*** Source Code =fifoReader.c=
#+BEGIN_SRC C
#include <fcntl.h> 
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>

int main() {
    const char* fifoName = "./myPipe1";
    int num;
    int fd = open(fifoName, O_RDONLY);              /** line 1 **/

    while (read(fd, &num, sizeof(num)) > 0)         /** line 2 **/ 
      printf("%i\n", num);
    close(fd);                                      /** line 3 **/
    unlink(fifoName);                               /** line 4 **/
    return 0;
}
#+END_SRC
** The Nginx Web Server
# chapter 3: nginx.txt
 Multiprocessing in production-grade software: the nginx web server

+ www.nginx.com
  + The web server is written in C.
  + nginx combines multiprocessing and non-blocking I/O as concurrency mechanisms.

+ nginx, like any modern web server that relies on multiprocessing for concurrency,
   is a "pre-forking" server.
  + nginx can be started as a /system service/ (at boot time), and is platform-neutral.

+ =nginx.conf=  ()configuration entries are key/value pairs: no XML!)
  #+begin_example 
user www-data;           ## www-data (name is arbitrary) is owner of workers
worker_processes 4;      ## default number of workers, might be set to processor count
pid /var/run/nginx.pid;  ## file /var/run/nginx.pid stores pid of master process

events {
   worker_connections 1024;  ## Max of 1024 connections per worker 
   ...                       ## (typical browsers open at least two connections to a 
                                site per client session)
    }   
  #+end_example

+ =ps -ef | grep nginx=
  #+begin_example 
Owner     pid   ppid   nginx process type

root      1803     1   master process /usr/sbin/nginx  ## command that started nginx
www-data  1804  1803   worker process
www-data  1805  1803   worker process
www-data  1807  1803   worker process
www-data  1808  1803   worker process
  #+end_example
** Execing and Forking Options in Multiprocessing
# chapter 3 execOverview.txt
 A second way for one executing program to start another

+ Review of the previously way, introduction of the new way:
  #+begin_example
        fork()
parent---------->child        ## Both parent and child continue to execute...

         exec...()
process1----------->process2  ## process2 replaces process1, which terminates
  #+end_example
+ In systems speak, an /image/ is an executable program. For instance,
  copying the system from one machine to another is called
  /re-imaging/.
  + In the multiprocessing /pipeExample/ code, the image is the
    compiled, executable program named /pipeExample/
+ A new process can be /spawned/ (created) under one of two distinct
  scenarios, which the difference between the fork() function and the
  exec-family of functions illustrates.
  + The exec-family consists of library functions that, under the
    hood, make the same system call.
+ In a successful call to fork(), the new child process executes the
  /same/ image as the parent that spawned it: the forked process is a
  clone. So the standard code idiom is this:
  #+BEGIN_SRC C
pid_t pid = fork();  /* parent executes this */
...                  /* check for success */
if (0 == pid) {      /* 0 returned to the child */
   ...               /* child code */
}
else {               /* parent code: fork returns child's pid to parent */
   ...               /* alternative parent test: if (pid > 0)
}
  #+END_SRC
+ In a successful call to an exec-function, replaces the current process image with
   a new image that's loaded into memory.
  #+BEGIN_SRC c
int flag = execl("/usr/bin/myGame", "myGame", 0);
if (-1 == flag) perror("Couldn't exec...");
/* on success, the 'myGame' program now executes */
  #+END_SRC
  + The new image has its own address space and other features. In
    summary, the old process stops execution and a new one begins
    execution.
  + The new process retains the pid (and ppid) of the one it replaces
    + The user and group properties are likewise unchanged.
*** Using the Shell
#+BEGIN_SRC sh
bash-3.2$ ./fileStatus tmp
File name: tmp

Information about file tmp:

Owner ID:    503
Group ID:    20
Byte size:   68
Last access: Fri Oct  6 11:10:23 2017
File type:   directory
Owner read:  Owner readable
Owner write: Owner writable

bash-3.2$ ./fileStatus fileStatus
File name: fileStatus

Information about file fileStatus:

Owner ID:    503
Group ID:    20
Byte size:   8808
Last access: Fri Oct  6 11:12:05 2017
File type:   regular
Owner read:  Owner readable
Owner write: Owner writable

bash-3.2$ ./execing
File name: tmp

Information about file tmp:

Owner ID:    503
Group ID:    20
Byte size:   68
Last access: Fri Oct  6 11:10:23 2017
File type:   directory
Owner read:  Owner readable
Owner write: Owner writable
#+END_SRC
*** Source Code
#+BEGIN_SRC C
/* To run: 

   -- compile this program (gcc -o execing execing.c) and fileStatus.c 
   --                      (gcc -o fileStatus fileStatus.c)
   -- create a subdirectory named tmp: mkdir tmp
   -- from the command line: ./execing

   This program 'execs' the fileStatus program, which outputs metadata about the tmp dir..
   Here's a depiction:

                   execv
   execing program------->fileStatus program
*/

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
  char* const args[] = {"./fileStatus", "tmp", 0};  /* fileStatus program, tmp directory */
  int ret = execv("./fileStatus", args);            /* "v" for "vector" */
  if (-1 == ret) {                                  /* check for failure */
    perror("execv(...) error");
    exit(-1);
  }
  else 
    printf("I'm here\n");                           /* never executes */
  return 0;
}
#+END_SRC
** Process Tracking and Management
# chapter 3 processTracking.txt
 Process tracking and context switching

+ Each process has a unique ID (pid), a non-negative integer.
  + A process's pid is recorded in the system's process table.
  + Library functions getpid() and getppid() get the pid and the
    parent's pid, respectively.
  + The pid of 0 is typically reserved for the /idle process/, the one
    that /runs/ when there's nothing else to run.
  + The /init process/ has a pid of 1: the first user-space process
    that the OS kernel spawns in the boot-up.
    + On shutdown, the init process is the last process to terminate:
      it waits for all of its children.
    + The init process starts other processes: system services such as
      the login service, etc.
+ Key data structures in a process /context/:
  + process table: tracks information per process, in particular
    information that allows a pre-empted process to restart later.
  + page table(s): translate virtual into physical addresses. Each
    process has its own, which effectively partitions virtual address
    spaces among processes.
  + file table: tracks, per process, files that a process has opened.
+ Every process has a user and group /owner/, which determines the
  process's access rights to resources.
  + Every process likewise belongs to a /process group/, which
    facilitates sending signals to every process in a group, to
    getting information about related processes, and so on.
  + In the default case, a child process belongs to the same as its
    parent.
+ Most modern systems use pre-emptive scheduling, with either
  fixed-length or variable-length time-slices: a process that exceeds
  the time-slice on a given run is pre-empted and sent back to a
  scheduling queue.
  + A process and a thread /context/ consists of key information about
    it.
    + For a process, key data structures such as the process table,
      the file table, and its page tables define the /context/.
+ Context switches, which occur during pre-emption, come in two
  flavors:
  + From one thread to another within the same process: /intraprocess
    switching/
  + From one process to another: /interprocess switching/
    + The big cost is the swapping out of one (virtual) address space
      for another: page tables
  + A process-level context switch is signficantly more expensive than
    a thread-level context switch.
    + The cost of thread-level switching is near zero on modern systems.
    + Depiction:
      #+begin_example
Process1      Process2        processor7
  Thread11      Thread21
  Thread12

1st scenario: Thread12 replaces Thread11 on processor7  + virtually no overhead

2nd scenario: Thread21 replaces Thread11 on processor7  + high overhead--
                                                          process context switch
      #+end_example
* Multiprocessing -- Vertiefung
# Multiprocessing Through Richer Code Examples
# eventuell überspringen: Chapter 4
/to be continued/ ... 

Examples from 
+ node.js ++
+ ipc -
+ nginx local socket -
+ exercise  -?
+ upsides and downsides of multiprocessing +
 
