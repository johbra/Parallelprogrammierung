<?xml version="1.0"?><st-source><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Users/johannes/Documents/lehre/Informatik/mySmalltalk/vw811.im' 'June 15, 2016' '5:50:02 PM')""An image file /Users/johannes/Documents/lehre/Informatik/mySmalltalk/vw811.im was created at 17:50:02 on 15. Juni 2016."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Users/johannes/Documents/lehre/Informatik/mySmalltalk/vw811.im' 'June 15, 2016' '5:50:09 PM')""An image file /Users/johannes/Documents/lehre/Informatik/mySmalltalk/vw811.im was created at 17:50:09 on 15. Juni 2016."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Users/johannes/Documents/lehre/Informatik/mySmalltalk/vw811.im' 'June 20, 2016' '2:09:48 PM')""An image file /Users/johannes/Documents/lehre/Informatik/mySmalltalk/vw811.im was created at 14:09:48 on 20. Juni 2016."</do-it><component-created><name>BinaerBaeume</name> <type>package</type></component-created><parcel-loaded><name>BinaerBaeume</name> <filename>(OS.LogicalFilename fromComponents: #('/' 'Volumes' 'Macintosh HD' 'Users' 'johannes' 'Box Sync' 'Publikationen' 'Objektmutation' 'BinaerBaeume.pcl'))</filename></parcel-loaded><component-created><name>BinaerBaeume</name> <type>package</type></component-created><parcel-loaded><name>BinaerBaeume</name> <filename>(OS.LogicalFilename fromComponents: #('/' 'Users' 'johannes' 'Box Sync' 'Publikationen' 'Objektmutation' 'BinaerBaeume.pcl'))</filename></parcel-loaded><methods><class-id>Binaerbaum class</class-id> <category>examples</category><body package="BinaerBaeume" selector="example4">example4	"Be able to add to and return the elements from a BinaryTree"	"Binaerbaum example"	| tree |	tree := self withRoot: 6 withBlock: [:new :old| new &lt; old].	#(12 6 34 #e 67 $e 89 'e' 10 3 6) do: [:i | 		tree add: i].	"add objects to the tree"	^tree  asOrderedCollection                                 "return objects in ascending order"</body></methods><do-it>Binaerbaum example</do-it><methods><class-id>Binaerbaum class</class-id> <category>examples</category><body package="BinaerBaeume" selector="example4">example4	"Be able to add to and return the elements from a BinaryTree"	"Binaerbaum example"	| tree |	tree := self withRoot: 6 withBlock: [:new :old| new &lt; old].	#(53) do: [:i | 		tree add: i].	"add objects to the tree"	^tree  asOrderedCollection                                 "return objects in ascending order"</body></methods><methods><class-id>Binaerbaum class</class-id> <category>examples</category><body package="BinaerBaeume" selector="example4">example4	"Be able to add to and return the elements from a BinaryTree"	"Binaerbaum4 example"	| tree |	tree := self withRoot: 6 withBlock: [:new :old| new &lt; old].	#(53) do: [:i | 		tree add: i].	"add objects to the tree"	^tree  asOrderedCollection                                 "return objects in ascending order"</body></methods><do-it>Binaerbaum example</do-it><methods><class-id>Binaerbaum class</class-id> <category>examples</category><body package="BinaerBaeume" selector="example4">example4	"Be able to add to and return the elements from a BinaryTree"	"Binaerbaum example4"	| tree |	tree := self withRoot: 6 withBlock: [:new :old| new &lt; old].	#(53) do: [:i | 		tree add: i].	"add objects to the tree"	^tree  asOrderedCollection                                 "return objects in ascending order"</body></methods><do-it>Binaerbaum example4</do-it><component-created><name>BinaerBaeume</name> <type>package</type></component-created><parcel-loaded><name>BinaerBaeume</name> <filename>(OS.LogicalFilename fromComponents: #('/' 'Users' 'johannes' 'Box Sync' 'Publikationen' 'Objektmutation' 'BinaerBaeume.pcl'))</filename></parcel-loaded><component-created><name>BinaerBaeume</name> <type>package</type></component-created><parcel-loaded><name>BinaerBaeume</name> <filename>(OS.LogicalFilename fromComponents: #('/' 'Users' 'johannes' 'Box Sync' 'Publikationen' 'Objektmutation' 'BinaerBaeume.pcl'))</filename></parcel-loaded><name-space><name>BinBaum</name><environment>Smalltalk</environment><private>false</private><imports>			private Core.*			</imports><category></category><attributes><package>BinaerBaeume</package></attributes></name-space><do-it>Binaerbaum relocateTo: BinBaum</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Blatt</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Blatt</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BinBaum.Binaerbaum</class-id> <category>initialize-release</category><body package="BinaerBaeume" selector="initialize:withBlock:"> initialize: anObject withBlock: aBlock	"initialisiert ein neues Exemplar mit anObject als Wert der Wurzel und aBlock als Vergleichsblock.	 Für ein neues Exemplar ist die Wurzel ein Blatt."	self root: (Blatt with: anObject).	self isLeftBlock: aBlock</body></methods><do-it>Knoten relocateTo: BinBaum</do-it><do-it>Blatt relocateTo: BinBaum</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NurLinks</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NurLinks</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NurRechts</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>NurRechts</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>EinNachfolger class</class-id> <category>instance creation</category><body package="BinaerBaeume" selector="from:andSuccValue:">from: einBlatt andSuccValue: aValue 	"erzeugt ein Exemplar mit Eintrag (value) und Anzahl (tally) des Blattes einBlatt.	Als Nachfolger (nextNode) wird ein neues Blatt mit aValue eingefügt."	^(self basicNew)		value: einBlatt value;		tally: einBlatt tally;		nextNode: (BinBaum.Blatt with: aValue);		yourself</body></methods><methods><class-id>ZweiNachfolger class</class-id> <category>instance creation</category><body package="BinaerBaeume" selector="from:andLeftNode:">from: einNurRechts andLeftNode: aValue 	"erzeugt ein Exemplar mit Eintrag (value), Anzahl (tally) und rechtem Nachfolger	(nextNode) aus dem Knoten einNurRechts. Als linker Nachfolger wird ein neues	Blatt mit aValue erzeugt."	^(self basicNew)		value: einNurRechts value;		tally: einNurRechts tally;		rightNode: einNurRechts nextNode;		leftNode: (BinBaum.Blatt with: aValue);		yourself</body></methods><methods><class-id>ZweiNachfolger class</class-id> <category>instance creation</category><body package="BinaerBaeume" selector="from:andRightNode:">from: einNurLinks andRightNode: aValue 	"erzeugt ein Exemplar mit Eintrag (value), Anzahl (tally) und linkem Nachfolger	(nextNode) aus dem Knoten einNurLinks. Als rechter Nachfolger wird ein neues	Blatt mit aValue erzeugt."	^(self basicNew)		value: einNurLinks value;		tally: einNurLinks tally;		leftNode: einNurLinks nextNode;		rightNode: (BinBaum.Blatt with: aValue);		yourself</body></methods><methods><class-id>BinBaum.Blatt</class-id> <category>adding</category><body package="BinaerBaeume" selector="add:in:">add: aValue in: einBinaerbaum 	"fuegt aValue dem Blatt hinzu. Wenn der Wert nicht mit dem	im Blatt gespeicherten uebereinstimmt, mutiert das Blatt zum	InnenKnoten."	| neuerKnoten |	super add: aValue in: einBinaerbaum.	aValue = self value 		ifFalse: 			[neuerKnoten := (einBinaerbaum isLeftBlock value: aValue value: self value) 						ifTrue: [NurLinks from: self andSuccValue: aValue]						ifFalse: [NurRechts from: self andSuccValue: aValue].			^self become: neuerKnoten]		ifTrue: [^self]</body></methods><do-it>EinNachfolger relocateTo: BinBaum</do-it><methods><class-id>BinBaum.EinNachfolger class</class-id> <category>instance creation</category><body package="BinaerBaeume" selector="from:andSuccValue:">from: einBlatt andSuccValue: aValue 	"erzeugt ein Exemplar mit Eintrag (value) und Anzahl (tally) des Blattes einBlatt.	Als Nachfolger (nextNode) wird ein neues Blatt mit aValue eingefügt."	^(self basicNew)		value: einBlatt value;		tally: einBlatt tally;		nextNode: (Blatt with: aValue);		yourself</body></methods><do-it>NurLinks relocateTo: BinBaum</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ZweiNachfolger</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ZweiNachfolger</staticKey> <definitionChange>added</definitionChange></component_static_change><methods><class-id>BinBaum.NurLinks</class-id> <category>adding</category><body package="BinaerBaeume" selector="add:in:">add: aValue in: einBinaerbaum 	"fuegt aValue dem Empfaenger hinzu. Wenn der Wert nicht mit dem	im Empfaenger gespeicherten uebereinstimmt, mutiert der Empfaenger zum	ZweiNachfolger."	super add: aValue in: einBinaerbaum.	aValue = self value 		ifFalse: 			[(einBinaerbaum isLeftBlock value: aValue value: self value) 				ifTrue: [^self nextNode add: aValue in: einBinaerbaum]				ifFalse: [^self become: (ZweiNachfolger from: self andRightNode: aValue)]]		ifTrue: [^self]</body></methods><do-it>NurRechts relocateTo: BinBaum</do-it><methods><class-id>BinBaum.NurRechts</class-id> <category>adding</category><body package="BinaerBaeume" selector="add:in:">add: aValue in: einBinaerbaum 	"fuegt aValue dem Empfaenger hinzu. Wenn der Wert nicht mit dem	im Empfaenger gespeicherten uebereinstimmt, mutiert der Empfaenger zum	ZweiNachfolger."	super add: aValue in: einBinaerbaum.	aValue = self value 		ifFalse: 			[(einBinaerbaum isLeftBlock value: aValue value: self value) 				ifTrue: [^self become: (ZweiNachfolger from: self andLeftNode: aValue)]				ifFalse: [^self nextNode add: aValue in: einBinaerbaum]]		ifTrue: [^self]</body></methods><do-it>ZweiNachfolger relocateTo: BinBaum</do-it><methods><class-id>BinBaum.ZweiNachfolger class</class-id> <category>instance creation</category><body package="BinaerBaeume" selector="from:andLeftNode:">from: einNurRechts andLeftNode: aValue 	"erzeugt ein Exemplar mit Eintrag (value), Anzahl (tally) und rechtem Nachfolger	(nextNode) aus dem Knoten einNurRechts. Als linker Nachfolger wird ein neues	Blatt mit aValue erzeugt."	^(self basicNew)		value: einNurRechts value;		tally: einNurRechts tally;		rightNode: einNurRechts nextNode;		leftNode: (Blatt with: aValue);		yourself</body></methods><methods><class-id>BinBaum.ZweiNachfolger class</class-id> <category>instance creation</category><body package="BinaerBaeume" selector="from:andRightNode:">from: einNurLinks andRightNode: aValue 	"erzeugt ein Exemplar mit Eintrag (value), Anzahl (tally) und linkem Nachfolger	(nextNode) aus dem Knoten einNurLinks. Als rechter Nachfolger wird ein neues	Blatt mit aValue erzeugt."	^(self basicNew)		value: einNurLinks value;		tally: einNurLinks tally;		leftNode: einNurLinks nextNode;		rightNode: (Blatt with: aValue);		yourself</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Users/johannes/Documents/lehre/Informatik/Parallelprogrammierung/Beispiele/FuenfPhilosophenInSmalltalk/fuenfphilosophen.im' 'October 23, 2017' '10:45:57 AM')""An image file /Users/johannes/Documents/lehre/Informatik/Parallelprogrammierung/Beispiele/FuenfPhilosophenInSmalltalk/fuenfphilosophen.im was created at 10:45:57 on 23. Oktober 2017."</do-it><class><name>Philosoph</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process sem state id session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FuenfPhilosophen</category><attributes><package>(none)</package></attributes></class><shared-variable><name>Ids</name><environment>Philosoph</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>(none)</package></attributes></shared-variable><shared-variable><name>Mutex</name><environment>Philosoph</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>(none)</package></attributes></shared-variable><methods><class-id>Philosoph class</class-id> <category>instance creation</category><body package="(none)" selector="new">new	^super new initialize</body></methods><methods><class-id>Philosoph class</class-id> <category>accessing</category><body package="(none)" selector="resetIds">resetIds	Ids := 0</body></methods><methods><class-id>Philosoph class</class-id> <category>accessing</category><body package="(none)" selector="resetMutex">resetMutex	Mutex := Semaphore new.	Mutex signal</body></methods><methods><class-id>Philosoph</class-id> <category>accessing</category><body package="(none)" selector="id">id	^id</body></methods><methods><class-id>Philosoph</class-id> <category>accessing</category><body package="(none)" selector="process">process	^process</body></methods><methods><class-id>Philosoph</class-id> <category>accessing</category><body package="(none)" selector="sem">sem	^sem</body></methods><methods><class-id>Philosoph</class-id> <category>accessing</category><body package="(none)" selector="session">session	^session</body></methods><methods><class-id>Philosoph</class-id> <category>accessing</category><body package="(none)" selector="session:">session: aPhilosophers 	session := aPhilosophers</body></methods><methods><class-id>Philosoph</class-id> <category>accessing</category><body package="(none)" selector="state">state	^state</body></methods><methods><class-id>Philosoph</class-id> <category>eating</category><body package="(none)" selector="releaseForks">releaseForks	""	Mutex critical: 			[state := 'denkend'.			self leftNeighbour try.			self rightNeighbour try]</body></methods><methods><class-id>Philosoph</class-id> <category>eating</category><body package="(none)" selector="takeTwoForks">takeTwoForks	""	Mutex critical: 			[state := 'hungrig'.			self try].	sem wait</body></methods><methods><class-id>Philosoph</class-id> <category>eating</category><body package="(none)" selector="try">try	""	state = 'hungrig' &amp; (self leftNeighbour state ~= 'essend') 		&amp; (self rightNeighbour state ~= 'essend') 			ifTrue: 				[state := 'essend'.				sem signal]</body></methods><methods><class-id>Philosoph</class-id> <category>initialization</category><body package="(none)" selector="initialize">initialize	id := Ids + 1.	Ids := Ids + 1.	sem := Semaphore new.	state := 'denkend'.	process := 			[| denkzeit denkDelay esszeit essDelay |			denkzeit := Random new next * 10000.			denkDelay := Delay forMilliseconds: denkzeit.			Transcript				cr;				show: 'Phil ' , id printString , ' ';				cr;				tab;				show: 'ich denke jetzt für ' , denkzeit printString , ' Millisekunden.'.			denkDelay wait.						[self takeTwoForks.			esszeit := Random new next * 10000.			essDelay := Delay forMilliseconds: esszeit.			Transcript				cr;				show: 'Phil ' , id printString , ' ';				cr;				tab;				show: 'ich esse jetzt für ' , esszeit printString , ' Millisekunden.'.			essDelay wait.			denkzeit := Random new next * 10000.			denkDelay := Delay forMilliseconds: denkzeit.			Transcript				cr;				show: 'Phil ' , id printString , ' ';				cr;				tab;				show: 'ich denke jetzt für ' , denkzeit printString , ' Millisekunden.'.			self releaseForks.			denkDelay wait] 					repeat] 					newProcess</body></methods><methods><class-id>Philosoph</class-id> <category>neighbours</category><body package="(none)" selector="leftNeighbour">leftNeighbour	""	^self session leftOf: self</body></methods><methods><class-id>Philosoph</class-id> <category>neighbours</category><body package="(none)" selector="rightNeighbour">rightNeighbour	""	^self session rightOf: self</body></methods><class><name>Philosophers</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>philosophers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>FuenfPhilosophen</category><attributes><package>(none)</package></attributes></class><methods><class-id>Philosophers class</class-id> <category>instance creation</category><body package="(none)" selector="new">new	""	^super new initialize</body></methods><methods><class-id>Philosophers</class-id> <category>initialization</category><body package="(none)" selector="initialize">initialize	"comment stating purpose of message"	philosophers := Array new: 5.	Philosoph resetIds.	Philosoph resetMutex.	1 to: 5		do: 			[:i | 			philosophers at: i put: Philosoph new.			(philosophers at: i) session: self]</body></methods><methods><class-id>Philosophers</class-id> <category>accessing</category><body package="(none)" selector="philosophers">philosophers	""	^philosophers</body></methods><methods><class-id>Philosophers</class-id> <category>neighbours</category><body package="(none)" selector="leftOf:">leftOf: aPhilosoph 	^philosophers 		at: (aPhilosoph id = 1 ifTrue: [5] ifFalse: [aPhilosoph id - 1])</body></methods><methods><class-id>Philosophers</class-id> <category>neighbours</category><body package="(none)" selector="rightOf:">rightOf: aPhilosoph 	^philosophers 		at: (aPhilosoph id = 5 ifTrue: [1] ifFalse: [aPhilosoph id + 1])</body></methods><do-it>phils := Philosophers new.</do-it><do-it>phils := Philosophers new.</do-it><do-it>(phils philosophers at: 1) process resume</do-it><do-it>(phils philosophers at: 1) process terminate</do-it><do-it>phils philosophers do: [:phil | phil process resume]</do-it><do-it>phils philosophers do: [:phil | phil process terminate]</do-it><do-it>Mutex</do-it><do-it>phils := Philosophers new.</do-it><do-it>phils philosophers at: 1</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/Users/johannes/Documents/lehre/Informatik/Parallelprogrammierung/Beispiele/FuenfPhilosophenInSmalltalk/fuenfphilosophen.im' 'October 23, 2017' '11:14:14 AM')""An image file /Users/johannes/Documents/lehre/Informatik/Parallelprogrammierung/Beispiele/FuenfPhilosophenInSmalltalk/fuenfphilosophen.im was created at 11:14:14 on 23. Oktober 2017."</do-it><do-it>phils := Philosophers new.</do-it><do-it>(phils philosophers at: 1) process resume</do-it><do-it>(phils philosophers at: 1) process terminate</do-it><do-it>phils philosophers do: [:phil | phil process resume]</do-it><do-it>phils philosophers do: [:phil | phil process terminate]</do-it><do-it>phils philosophers do: [:phil | phil process resume]</do-it><do-it>phils := Philosophers new.</do-it><do-it>phils philosophers do: [:phil | phil process resume]</do-it><do-it>phils philosophers do: [:phil | phil process terminate]</do-it><do-it>phils philosophers do: [:phil | phil process terminate]</do-it>